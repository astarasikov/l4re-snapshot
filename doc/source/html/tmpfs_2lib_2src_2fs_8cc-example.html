<html>
  <head>
    <title>L4Re Reference Manual</title>      
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="tabs.css" rel="stylesheet" type="text/css">
  </HEAD>

  <body style="background: #fff url(header-bg.png) repeat-x scroll 0 0">
   <div>
    <div style="text-align: center; margin-bottom: 10px; border-width: 0 0 1px 0; border-color: #000; border-style: solid">
    L4Re - L4 Runtime Environment
    </div>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>tmpfs/lib/src/fs.cc</h1>  </div>
</div>
<div class="contents">
<p>Example file system for <a class="el" href="namespaceL4Re_1_1Vfs.html" title="Virtual file system for interfaces POSIX libc.">L4Re::Vfs</a>.</p>
<div class="fragment"><pre class="fragment">
<span class="comment">/*</span>
<span class="comment"> * (c) 2010 Adam Lackorzynski &lt;adam@os.inf.tu-dresden.de&gt;,</span>
<span class="comment"> *          Alexander Warg &lt;warg@os.inf.tu-dresden.de&gt;</span>
<span class="comment"> *     economic rights: Technische Universit√§t Dresden (Germany)</span>
<span class="comment"> * This file is part of TUD:OS and distributed under the terms of the</span>
<span class="comment"> * GNU Lesser General Public License 2.1.</span>
<span class="comment"> * Please see the COPYING-LGPL-2.1 file for details.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;l4/l4re_vfs/backend&gt;</span>
<span class="preprocessor">#include &lt;l4/cxx/string&gt;</span>
<span class="preprocessor">#include &lt;l4/cxx/avl_tree&gt;</span>

<span class="preprocessor">#include &lt;sys/stat.h&gt;</span>
<span class="preprocessor">#include &lt;sys/ioctl.h&gt;</span>
<span class="preprocessor">#include &lt;dirent.h&gt;</span>

<span class="preprocessor">#include &lt;cstdio&gt;</span>

<span class="keyword">namespace </span>{

<span class="keyword">using namespace </span>L4Re::Vfs;
<span class="keyword">using</span> cxx::Ref_ptr;

<span class="keyword">class </span>File_data
{
<span class="keyword">public</span>:
  File_data() : _buf(0), _size(0) {}

  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> put(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset,
                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bufsize, <span class="keywordtype">void</span> *srcbuf);
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keyword">get</span>(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset,
                    <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bufsize, <span class="keywordtype">void</span> *dstbuf);

  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _size; }

  ~File_data() <span class="keywordflow">throw</span>() { free(_buf); }

<span class="keyword">private</span>:
  <span class="keywordtype">void</span> *_buf;
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> _size;
};

<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
File_data::put(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bufsize, <span class="keywordtype">void</span> *srcbuf)
{
  <span class="keywordflow">if</span> (offset + bufsize &gt; _size)
    {
      _size = offset + bufsize;
      _buf = realloc(_buf, _size);
    }

  <span class="keywordflow">if</span> (!_buf)
    <span class="keywordflow">return</span> 0;

  memcpy((<span class="keywordtype">char</span> *)_buf + offset, srcbuf, bufsize);
  <span class="keywordflow">return</span> bufsize;
}

<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>
File_data::get(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> offset, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> bufsize, <span class="keywordtype">void</span> *dstbuf)
{
  <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> s = bufsize;

  <span class="keywordflow">if</span> (offset &gt; _size)
    <span class="keywordflow">return</span> 0;

  <span class="keywordflow">if</span> (offset + bufsize &gt; _size)
    s = _size - offset;

  memcpy(dstbuf, (<span class="keywordtype">char</span> *)_buf + offset, s);
  <span class="keywordflow">return</span> s;
}


<span class="keyword">class </span>Node : <span class="keyword">public</span> cxx::Avl_tree_node
{
<span class="keyword">public</span>:
  Node(<span class="keyword">const</span> <span class="keywordtype">char</span> *path, mode_t mode)
    : _ref_cnt(0), _path(strdup(path))
  {
    memset(&amp;_info, 0, <span class="keyword">sizeof</span>(_info));
    _info.st_mode = mode;
  }

  <span class="keyword">const</span> <span class="keywordtype">char</span> *path()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _path; }
  <span class="keyword">struct </span>stat64 *info() { <span class="keywordflow">return</span> &amp;_info; }

  <span class="keywordtype">void</span> add_ref() <span class="keywordflow">throw</span>() { ++_ref_cnt; }
  <span class="keywordtype">int</span> remove_ref() <span class="keywordflow">throw</span>() { <span class="keywordflow">return</span> --_ref_cnt; }

  <span class="keywordtype">bool</span> is_dir()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> S_ISDIR(_info.st_mode); }

  <span class="keyword">virtual</span> ~Node() { free(_path); }

<span class="keyword">private</span>:
  <span class="keywordtype">int</span>           _ref_cnt;
  <span class="keywordtype">char</span>         *_path;
  <span class="keyword">struct </span>stat64 _info;
};

<span class="keyword">struct </span>Node_get_key
{
  <span class="keyword">typedef</span> cxx::String Key_type;
  <span class="keyword">static</span> Key_type key_of(Node <span class="keyword">const</span> *n)
  { <span class="keywordflow">return</span> n-&gt;path(); }
};

<span class="keyword">struct </span>Path_avl_tree_compare
{
  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> <span class="keywordtype">char</span> *l, <span class="keyword">const</span> <span class="keywordtype">char</span> *r)<span class="keyword"> const</span>
<span class="keyword">  </span>{ <span class="keywordflow">return</span> strcmp(l, r) &lt; 0; }
  <span class="keywordtype">bool</span> operator () (<span class="keyword">const</span> cxx::String l, <span class="keyword">const</span> cxx::String r)<span class="keyword"> const</span>
<span class="keyword">  </span>{ <span class="keywordflow">return</span> strncmp(l.start(), r.start(), <a name="a0"></a><a class="code" href="group__cxx__api.html#ga90dd0646443b89cd0df8ec5b0884fccd" title="Get the minimum of a and b.">cxx::min</a>(l.len(), r.len())) &lt; 0; }
};

<span class="keyword">class </span>Pers_file : <span class="keyword">public</span> Node
{
<span class="keyword">public</span>:
  Pers_file(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, mode_t mode)
    : Node(name, (mode &amp; 0777) | __S_IFREG) {}
  File_data <span class="keyword">const</span> &amp;data()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _data; }
  File_data &amp;data() { <span class="keywordflow">return</span> _data; }
<span class="keyword">private</span>:
  File_data     _data;
};

<span class="keyword">class </span>Pers_dir : <span class="keyword">public</span> Node
{
<span class="keyword">private</span>:
  <span class="keyword">typedef</span> <a name="_a1"></a><a class="code" href="classcxx_1_1Avl__tree.html" title="A generic AVL tree.">cxx::Avl_tree&lt;Node, Node_get_key, Path_avl_tree_compare&gt;</a> Tree;
  Tree _tree;

<span class="keyword">public</span>:
  Pers_dir(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, mode_t mode)
    : Node(name, (mode &amp; 0777) | __S_IFDIR) {}
  Ref_ptr&lt;Node&gt; find_path(cxx::String);
  <span class="keywordtype">bool</span> add_node(Ref_ptr&lt;Node&gt; <span class="keyword">const</span> &amp;);

  <span class="keyword">typedef</span> Tree::Const_iterator Const_iterator;
  Const_iterator begin()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _tree.begin(); }
  Const_iterator end()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> _tree.end(); }
};

Ref_ptr&lt;Node&gt; Pers_dir::find_path(cxx::String path)
{
  <span class="keywordflow">return</span> cxx::ref_ptr(_tree.find_node(path));
}

<span class="keywordtype">bool</span> Pers_dir::add_node(Ref_ptr&lt;Node&gt; <span class="keyword">const</span> &amp;n)
{
  <span class="keywordtype">bool</span> e = _tree.insert(n.ptr()).second;
  <span class="keywordflow">if</span> (e)
    n-&gt;add_ref();
  <span class="keywordflow">return</span> e;
}

<span class="keyword">class </span>Tmpfs_dir : <span class="keyword">public</span> <a name="_a2"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html" title="Boiler plate class for implementing an open file for L4Re::Vfs.">Be_file</a>
{
<span class="keyword">public</span>:
  <span class="keyword">explicit</span> Tmpfs_dir(Ref_ptr&lt;Pers_dir&gt; <span class="keyword">const</span> &amp;d) <span class="keywordflow">throw</span>()
    : _dir(d), _getdents_state(<span class="keyword">false</span>) {}
  <span class="keywordtype">int</span> get_entry(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keywordtype">int</span>, mode_t, Ref_ptr&lt;File&gt; *) <span class="keywordflow">throw</span>();
  ssize_t getdents(<span class="keywordtype">char</span> *, <span class="keywordtype">size_t</span>) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> fstat64(<span class="keyword">struct</span> stat64 *buf) <span class="keyword">const</span> <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> <a name="a3"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#abf77afa179777d5aca13c61244afecba" title="Default backend for POSIX utime.">utime</a>(<span class="keyword">const</span> <span class="keyword">struct</span> utimbuf *) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> <a name="a4"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#acfd6ef7ddba46e3948c315dbaba245a9" title="Default backend for POSIX chmod and fchmod.">fchmod</a>(mode_t) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> <a name="a5"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#a0ff050f5910c31c38a905df91e343674" title="Default backend for POSIX mkdir and mkdirat.">mkdir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *, mode_t) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> <a name="a6"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#afa39a5db644ea0cb62b543ef61ddb7d7" title="Default backend for POSIX unlink, unlinkat.">unlink</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> <a name="a7"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#aa20089cc0da8d3e4d8617a0bc5893612" title="Default backend for POSIX rename, renameat.">rename</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *, <span class="keyword">const</span> <span class="keywordtype">char</span> *) <span class="keywordflow">throw</span>();

<span class="keyword">private</span>:
  <span class="keywordtype">int</span> walk_path(cxx::String <span class="keyword">const</span> &amp;_s,
                Ref_ptr&lt;Node&gt; *ret, cxx::String *remaining = 0);

  Ref_ptr&lt;Pers_dir&gt; _dir;
  <span class="keywordtype">bool</span> _getdents_state;
  Pers_dir::Const_iterator _getdents_iter;
};

<span class="keyword">class </span>Tmpfs_file : <span class="keyword">public</span> Be_file_pos
{
<span class="keyword">public</span>:
  <span class="keyword">explicit</span> Tmpfs_file(Ref_ptr&lt;Pers_file&gt; <span class="keyword">const</span> &amp;f) <span class="keywordflow">throw</span>()
    : Be_file_pos(), _file(f) {}

  off64_t size() <span class="keyword">const</span> <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> fstat64(<span class="keyword">struct</span> stat64 *buf) <span class="keyword">const</span> <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> ioctl(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>, va_list) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> utime(<span class="keyword">const</span> <span class="keyword">struct</span> utimbuf *) <span class="keywordflow">throw</span>();
  <span class="keywordtype">int</span> fchmod(mode_t) <span class="keywordflow">throw</span>();

<span class="keyword">private</span>:
  ssize_t preadv(<span class="keyword">const</span> <span class="keyword">struct</span> iovec *v, <span class="keywordtype">int</span> iovcnt, off64_t p) <span class="keywordflow">throw</span>();
  ssize_t pwritev(<span class="keyword">const</span> <span class="keyword">struct</span> iovec *v, <span class="keywordtype">int</span> iovcnt, off64_t p) <span class="keywordflow">throw</span>();
  Ref_ptr&lt;Pers_file&gt; _file;
};

ssize_t Tmpfs_file::preadv(<span class="keyword">const</span> <span class="keyword">struct</span> iovec *v, <span class="keywordtype">int</span> iovcnt, off64_t p) <span class="keywordflow">throw</span>()
{
  <span class="keywordflow">if</span> (iovcnt &lt; 0)
    <span class="keywordflow">return</span> -EINVAL;

  ssize_t sum = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iovcnt; ++i)
    {
      sum  += _file-&gt;data().get(p, v[i].iov_len, v[i].iov_base);
      p += v[i].iov_len;
    }
  <span class="keywordflow">return</span> sum;
}

ssize_t Tmpfs_file::pwritev(<span class="keyword">const</span> <span class="keyword">struct</span> iovec *v, <span class="keywordtype">int</span> iovcnt, off64_t p) <span class="keywordflow">throw</span>()
{
  <span class="keywordflow">if</span> (iovcnt &lt; 0)
    <span class="keywordflow">return</span> -EINVAL;

  ssize_t sum = 0;
  <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; iovcnt; ++i)
    {
      sum  += _file-&gt;data().put(p, v[i].iov_len, v[i].iov_base);
      p += v[i].iov_len;
    }
  <span class="keywordflow">return</span> sum;
}

<span class="keywordtype">int</span> Tmpfs_file::fstat64(<span class="keyword">struct</span> stat64 *buf) <span class="keyword">const</span> <span class="keywordflow">throw</span>()
{
  _file-&gt;info()-&gt;st_size = _file-&gt;data().size();
  memcpy(buf, _file-&gt;info(), <span class="keyword">sizeof</span>(*buf));
  <span class="keywordflow">return</span> 0;
}

off64_t Tmpfs_file::size() <span class="keyword">const</span> <span class="keywordflow">throw</span>()
{ <span class="keywordflow">return</span> _file-&gt;data().size(); }

<span class="keywordtype">int</span>
Tmpfs_file::ioctl(<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> v, va_list args) <span class="keywordflow">throw</span>()
{
  <span class="keywordflow">switch</span> (v)
    {
    <span class="keywordflow">case</span> FIONREAD: <span class="comment">// return amount of data still available</span>
      <span class="keywordtype">int</span> *available = va_arg(args, <span class="keywordtype">int</span> *);
      *available = _file-&gt;data().size() - pos();
      <span class="keywordflow">return</span> 0;
    };
  <span class="keywordflow">return</span> -EINVAL;
}

<span class="keywordtype">int</span>
Tmpfs_file::utime(<span class="keyword">const</span> <span class="keyword">struct</span> utimbuf *times) <span class="keywordflow">throw</span>()
{
  _file-&gt;info()-&gt;st_atime = times-&gt;actime;
  _file-&gt;info()-&gt;st_mtime = times-&gt;modtime;
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span>
Tmpfs_file::fchmod(mode_t m) <span class="keywordflow">throw</span>()
{
  _file-&gt;info()-&gt;st_mode = m;
  <span class="keywordflow">return</span> 0;
}


<span class="keywordtype">int</span>
Tmpfs_dir::get_entry(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, <span class="keywordtype">int</span> flags, mode_t mode,
                     Ref_ptr&lt;File&gt; *file) <span class="keywordflow">throw</span>()
{
  Ref_ptr&lt;Node&gt; path;
  <span class="keywordflow">if</span> (!*name)
    {
      *file = <span class="keyword">this</span>;
      <span class="keywordflow">return</span> 0;
    }

  cxx::String n = name;

  <span class="keywordtype">int</span> e = walk_path(n, &amp;path, &amp;n);

  <span class="keywordflow">if</span> (e == -ENOTDIR)
    <span class="keywordflow">return</span> e;

  <span class="keywordflow">if</span> (!(flags &amp; O_CREAT) &amp;&amp; e &lt; 0)
    <span class="keywordflow">return</span> e;

  <span class="keywordflow">if</span> ((flags &amp; O_CREAT) &amp;&amp; e == -ENOENT)
    {
      Ref_ptr&lt;Node&gt; node(<span class="keyword">new</span> Pers_file(n.start(), mode));
      <span class="comment">// when ENOENT is return, path is always a directory</span>
      <span class="keywordtype">bool</span> e = cxx::ref_ptr_static_cast&lt;Pers_dir&gt;(path)-&gt;add_node(node);
      <span class="keywordflow">if</span> (!e)
        <span class="keywordflow">return</span> -ENOMEM;
      path = node;
    }

  <span class="keywordflow">if</span> (path-&gt;is_dir())
    *file = <span class="keyword">new</span> Tmpfs_dir(cxx::ref_ptr_static_cast&lt;Pers_dir&gt;(path));
  <span class="keywordflow">else</span>
    *file = <span class="keyword">new</span> Tmpfs_file(cxx::ref_ptr_static_cast&lt;Pers_file&gt;(path));

  <span class="keywordflow">if</span> (!*file)
    <span class="keywordflow">return</span> -ENOMEM;


  <span class="keywordflow">return</span> 0;
}

ssize_t
Tmpfs_dir::getdents(<span class="keywordtype">char</span> *buf, <span class="keywordtype">size_t</span> sz) <span class="keywordflow">throw</span>()
{
  <span class="keyword">struct </span>dirent64 *d = (<span class="keyword">struct </span>dirent64 *)buf;
  ssize_t ret = 0;

  <span class="keywordflow">if</span> (!_getdents_state)
    {
      _getdents_iter = _dir-&gt;begin();
      _getdents_state = <span class="keyword">true</span>;
    }
  <span class="keywordflow">else</span> <span class="keywordflow">if</span> (_getdents_iter == _dir-&gt;end())
    {
      _getdents_state = <span class="keyword">false</span>;
      <span class="keywordflow">return</span> 0;
    }

  <span class="keywordflow">for</span> (; _getdents_iter != _dir-&gt;end(); ++_getdents_iter)
    {
      <span class="keywordtype">unsigned</span> l = strlen(_getdents_iter-&gt;path()) + 1;
      <span class="keywordflow">if</span> (l &gt; <span class="keyword">sizeof</span>(d-&gt;d_name))
        l = <span class="keyword">sizeof</span>(d-&gt;d_name);

      <span class="keywordtype">unsigned</span> n = offsetof (<span class="keyword">struct</span> dirent64, d_name) + l;
      n = (n + <span class="keyword">sizeof</span>(long) - 1) &amp; ~(<span class="keyword">sizeof</span>(long) - 1);

      <span class="keywordflow">if</span> (n &gt; sz)
        <span class="keywordflow">break</span>;

      d-&gt;d_ino = 1;
      d-&gt;d_off = 0;
      memcpy(d-&gt;d_name, _getdents_iter-&gt;path(), l);
      d-&gt;d_reclen = n;
      d-&gt;d_type   = DT_REG;
      ret += n;
      sz  -= n;
      d    = (<span class="keyword">struct </span>dirent64 *)((<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)d + n);
    }

  <span class="keywordflow">return</span> ret;
}

<span class="keywordtype">int</span>
Tmpfs_dir::fstat64(<span class="keyword">struct</span> stat64 *buf) <span class="keyword">const</span> <span class="keywordflow">throw</span>()
{
  memcpy(buf, _dir-&gt;info(), <span class="keyword">sizeof</span>(*buf));
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span>
<a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#abf77afa179777d5aca13c61244afecba" title="Default backend for POSIX utime.">Tmpfs_dir::utime</a>(<span class="keyword">const</span> <span class="keyword">struct</span> utimbuf *times) <span class="keywordflow">throw</span>()
{
  _dir-&gt;info()-&gt;st_atime = times-&gt;actime;
  _dir-&gt;info()-&gt;st_mtime = times-&gt;modtime;
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span>
<a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#acfd6ef7ddba46e3948c315dbaba245a9" title="Default backend for POSIX chmod and fchmod.">Tmpfs_dir::fchmod</a>(mode_t m) <span class="keywordflow">throw</span>()
{
  _dir-&gt;info()-&gt;st_mode = m;
  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span>
Tmpfs_dir::walk_path(cxx::String <span class="keyword">const</span> &amp;_s,
                     Ref_ptr&lt;Node&gt; *ret, cxx::String *remaining)
{
  Ref_ptr&lt;Pers_dir&gt; p = _dir;
  cxx::String s = _s;
  Ref_ptr&lt;Node&gt; n;

  <span class="keywordflow">while</span> (1)
    {
      <span class="keywordflow">if</span> (s.len() == 0)
        {
          *ret = p;
          <span class="keywordflow">return</span> 0;
        }

      cxx::String::Index sep = s.find(<span class="stringliteral">&quot;/&quot;</span>);

      <span class="keywordflow">if</span> (sep - s.start() == 1 &amp;&amp; *s.start() == <span class="charliteral">&#39;.&#39;</span>)
        {
          s = s.substr(s.start() + 2);
          <span class="keywordflow">continue</span>;
        }

      n = p-&gt;find_path(s.head(sep - s.start()));

      <span class="keywordflow">if</span> (!n)
        {
          *ret = p;
          <span class="keywordflow">if</span> (remaining)
            *remaining = s.head(sep - s.start());
          <span class="keywordflow">return</span> -ENOENT;
        }


      <span class="keywordflow">if</span> (sep == s.end())
        {
          *ret = n;
          <span class="keywordflow">return</span> 0;
        }

      <span class="keywordflow">if</span> (!n-&gt;is_dir())
        <span class="keywordflow">return</span> -ENOTDIR;

      s = s.substr(sep + 1);

      p = cxx::ref_ptr_static_cast&lt;Pers_dir&gt;(n);
    }

  *ret = n;

  <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span>
<a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#a0ff050f5910c31c38a905df91e343674" title="Default backend for POSIX mkdir and mkdirat.">Tmpfs_dir::mkdir</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name, mode_t mode) <span class="keywordflow">throw</span>()
{
  Ref_ptr&lt;Node&gt; node = _dir;
  cxx::String p = cxx::String(name);
  cxx::String path, last = p;
  cxx::String::Index s = p.rfind(<span class="stringliteral">&quot;/&quot;</span>);

  <span class="comment">// trim /&#39;s at the end</span>
  <span class="keywordflow">while</span> (p.len() &amp;&amp; s == p.end() - 1)
    {
      p.len(p.len() - 1);
      s = p.rfind(<span class="stringliteral">&quot;/&quot;</span>);
    }

  <span class="comment">//printf(&quot;MKDIR &#39;%s&#39; p=%p %p\n&quot;, name, p.start(), s);</span>

  <span class="keywordflow">if</span> (s != p.end())
    {
      path = p.head(s);
      last = p.substr(s + 1, p.end() - s);

      <span class="keywordtype">int</span> e = walk_path(path, &amp;node);
      <span class="keywordflow">if</span> (e &lt; 0)
        <span class="keywordflow">return</span> e;
    }

  <span class="keywordflow">if</span> (!node-&gt;is_dir())
    <span class="keywordflow">return</span> -ENOTDIR;

  <span class="comment">// due to path walking we can end up with an empty name</span>
  <span class="keywordflow">if</span> (p.len() == 0 || p == cxx::String(<span class="stringliteral">&quot;.&quot;</span>))
    <span class="keywordflow">return</span> 0;

  Ref_ptr&lt;Pers_dir&gt; dnode = cxx::ref_ptr_static_cast&lt;Pers_dir&gt;(node);

  Ref_ptr&lt;Pers_dir&gt; dir(<span class="keyword">new</span> Pers_dir(last.start(), mode));
  <span class="keywordflow">return</span> dnode-&gt;add_node(dir) ? 0 : -EEXIST;
}

<span class="keywordtype">int</span>
<a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#afa39a5db644ea0cb62b543ef61ddb7d7" title="Default backend for POSIX unlink, unlinkat.">Tmpfs_dir::unlink</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *name) <span class="keywordflow">throw</span>()
{
  cxx::Ref_ptr&lt;Node&gt; n;

  <span class="keywordtype">int</span> e = walk_path(name, &amp;n);
  <span class="keywordflow">if</span> (e &lt; 0)
    <span class="keywordflow">return</span> -ENOENT;

  printf(<span class="stringliteral">&quot;Unimplemented (if file exists): %s(%s)\n&quot;</span>, __func__, name); 
  <span class="keywordflow">return</span> -ENOMEM;
}

<span class="keywordtype">int</span>
<a class="code" href="classL4Re_1_1Vfs_1_1Be__file.html#aa20089cc0da8d3e4d8617a0bc5893612" title="Default backend for POSIX rename, renameat.">Tmpfs_dir::rename</a>(<span class="keyword">const</span> <span class="keywordtype">char</span> *old, <span class="keyword">const</span> <span class="keywordtype">char</span> *newn) <span class="keywordflow">throw</span>()
{
  printf(<span class="stringliteral">&quot;Unimplemented: %s(%s, %s)\n&quot;</span>, __func__, old, newn); 
  <span class="keywordflow">return</span> -ENOMEM;
}



<span class="keyword">class </span>Tmpfs_fs : <span class="keyword">public</span> <a name="_a8"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file__system.html" title="Boilerplate class for implementing a L4Re::Vfs::File_system.">Be_file_system</a>
{
<span class="keyword">public</span>:
  Tmpfs_fs() : <a name="a9"></a><a class="code" href="classL4Re_1_1Vfs_1_1Be__file__system.html#a2ba2f710380740f0e5d4f7188778724a" title="Create a file-system object for the given fstype.">Be_file_system</a>(<span class="stringliteral">&quot;tmpfs&quot;</span>) {}
  <span class="keywordtype">int</span> <a name="a10"></a><a class="code" href="classL4Re_1_1Vfs_1_1File__system.html#a096b1608fa60e2b2a037281cb0c13f74" title="Create a directory object dir representing source mounted with this file system.">mount</a>(<span class="keywordtype">char</span> <span class="keyword">const</span> *source, <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> mountflags,
            <span class="keywordtype">void</span> <span class="keyword">const</span> *data, cxx::Ref_ptr&lt;File&gt; *dir) <span class="keywordflow">throw</span>()
  {
    (void)mountflags;
    (void)source;
    (void)data;
    *dir = cxx::ref_ptr(<span class="keyword">new</span> Tmpfs_dir(cxx::ref_ptr(<span class="keyword">new</span> Pers_dir(<span class="stringliteral">&quot;root&quot;</span>, 0777))));
    <span class="keywordflow">if</span> (!*dir)
      <span class="keywordflow">return</span> -ENOMEM;
    <span class="keywordflow">return</span> 0;
  }
};

<span class="keyword">static</span> Tmpfs_fs _tmpfs L4RE_VFS_FILE_SYSTEM_ATTRIBUTE;

}
</pre></div> </div>
</div>
    <div style="background-color: #fff; border-width: 1px 0 0 0; border-color: #000; border-style: solid; text-align: center; margin-top: 10px">
    L4Re - L4 Runtime Environment
    </div>
   </div>
  </body>
</html>
