<html>
  <head>
    <title>L4Re Reference Manual</title>      
    <link href="doxygen.css" rel="stylesheet" type="text/css">
    <link href="tabs.css" rel="stylesheet" type="text/css">
  </HEAD>

  <body style="background: #fff url(header-bg.png) repeat-x scroll 0 0">
   <div>
    <div style="text-align: center; margin-bottom: 10px; border-width: 0 0 1px 0; border-color: #000; border-style: solid">
    L4Re - L4 Runtime Environment
    </div>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript">
function hasClass(ele,cls) {
  return ele.className.match(new RegExp('(\\s|^)'+cls+'(\\s|$)'));
}

function addClass(ele,cls) {
  if (!this.hasClass(ele,cls)) ele.className += " "+cls;
}

function removeClass(ele,cls) {
  if (hasClass(ele,cls)) {
    var reg = new RegExp('(\\s|^)'+cls+'(\\s|$)');
    ele.className=ele.className.replace(reg,' ');
  }
}

function toggleVisibility(linkObj) {
 var base = linkObj.getAttribute('id');
 var summary = document.getElementById(base + '-summary');
 var content = document.getElementById(base + '-content');
 var trigger = document.getElementById(base + '-trigger');
 if ( hasClass(linkObj,'closed') ) {
   summary.style.display = 'none';
   content.style.display = 'block';
   trigger.src = 'open.png';
   removeClass(linkObj,'closed');
   addClass(linkObj,'opened');
 } else if ( hasClass(linkObj,'opened') ) {
   summary.style.display = 'block';
   content.style.display = 'none';
   trigger.src = 'closed.png';
   removeClass(linkObj,'opened');
   addClass(linkObj,'closed');
 }
 return false;
}
</script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="main.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="pages.html"><span>Related&nbsp;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="examples.html"><span>Examples</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Fiasco.OC &amp; <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface.">L4</a> Runtime Environment (<a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a>) </h1>  </div>
</div>
<div class="contents">
<h2><a class="anchor" id="l4re_concepts_preface"></a>
Preface</h2>
<p>The intention of this document is to provide a birds eye overview about <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> and about the environment in which typical applications and servers run. We highlight here the principled functionality of the servers in the environment but do not discuss their specific interfaces. Detailed documentation about these interface is available in the modules section.</p>
<p>The document is meant as a general overview repeating many design concepts of L4-based systems and capability systems in general. We do though assume familiarity with C++ and an idea on the general concepts and terms of <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface.">L4</a>: threads --- as an abstraction for execution ---, tasks --- holding the capabilities to kernel objects that are accessible by the threads executing in this task ---, and <a class="el" href="group__l4__ipc__api.html">IPC</a> over <a class="el" href="group__l4__kernel__object__gate__api.html">IPC-gates</a> to send messages and to transfer capabilities between tasks.</p>
<h2><a class="anchor" id="l4re_concepts_structure"></a>
General System Structure</h2>
<p>The system has a multi-tier architecture consisting of the following layers depicted in the figure below:</p>
<ul>
<li><b>Microkernel</b> The microkernel is the component at the lowest level of the software stack. It is the only piece of software that is running in the privileged mode of the processor.</li>
</ul>
<ul>
<li><b>Tasks</b> Tasks are the basic containers (address spaces) in which system services and applications are executed. They run in the processor's deprivileged user mode.</li>
</ul>
<div align="center">
<img src="l4re-basic.png" alt="l4re-basic.png"/>
<p><strong>Basic Structure of an L4Re based system</strong></p></div>
 In terms of functionality, the system is structured as follows:</p>
<ul>
<li><b>Microkernel</b> The kernel provides primitives to execute programs in tasks, to enforce isolation among them, and to provide means of secure communication in order to let them cooperate. As the kernel is the most privileged, security-critical software component in the system, it is a general design goal to make it as small as possible in order to reduce its attack surface. It provides only a minimal set of mechanisms that are necessary to support applications.</li>
</ul>
<ul>
<li><b>Runtime Environment</b> The small kernel offers a concise set of interfaces, but these are not necessarily suited for building applications directly on top of it. The <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface.">L4</a> Runtime Environment aims at providing more convenient abstractions for application development. It comprises low-level software components that interface directly with the microkernel. The root pager <em>sigma0</em> and the root task <em>Moe</em> are the most basic components of the runtime environment. Other services (e.g., for device enumeration) use interfaces provided by them.</li>
</ul>
<ul>
<li><b>Applications</b> Applications run on top of the system and use services provided by the Runtime Environment -- or by other applications. There may be several types of applications in the system and even virtual machine monitors and device drivers are considered applications in the terminology used in this document. They are running alongside other applications on the system.</li>
</ul>
<p>Lending terminology from the distributed systems area, applications offering services to other applications are usually called <em>servers</em>, whereas applications using those services are named <em>clients</em>. Being in both roles is also common, for instance, a file system server may be viewed as a server with respect to clients using the file system, while the server itself may also act as a client of a hard disk driver.</p>
<p>In the following sections, we discuss the basic concepts of our microkernel and its runtime environment in more depth.</p>
<h2><a class="anchor" id="l4re_concepts_fiasco"></a>
The Fiasco.OC Microkernel</h2>
<p>The Fiasco.OC microkernel is the lowest-level piece of software running in an L4-based system. The microkernel is the only program that runs in privileged processor mode. It does not include complex services such as program loading, device drivers, or file systems; those are implemented in user-level programs on top of it (a basic set these services and abstractions is provided by the <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface.">L4</a> Runtime Environment).</p>
<p>Fiasco.OC kernel services are implemented in kernel objects. Tasks hold references to kernel objects in their respective <em>"object space"</em>, which is a kernel-protected table. These references are called <em>capabilities</em>. Fiasco system calls are function invocations on kernel objects through the corresponding capabilities. These can be thought of as function invocations on object references in an object-oriented programming environment. Furthermore, if a task owns a capability, it may grant other tasks the same (or fewer) rights on this object by passing the capability from its own to the other task's object space.</p>
<p>From a design perspective, capabilities are a concept that enables flexibility in the system structure. A thread that invokes an object through a capability does not need to care about where this object is implemented. In fact, it is possible to implement all objects either in the kernel or in a user-level server and replace one implementation with the other transparently for clients.</p>
<h3><a class="anchor" id="l4re_concepts_fiasco_ipc"></a>
Communication</h3>
<p>The basic communication mechanism in L4-based systems is called <em>"Inter Process Communication (IPC)"</em>. It is always synchronous, i.e. both communication partners need to actively rendezvous for IPC. In addition to transmitting arbitrary data between threads, IPC is also used to resolve hardware exceptions, faults and for virtual memory management.</p>
<h3><a class="anchor" id="l4re_concepts_fiasco_kobjects"></a>
Kernel Objects</h3>
<p>The following list gives a short overview of the kernel objects provided by the Fiasco.OC microkernel:</p>
<ul>
<li><b>Task</b> A task comprises a memory address space (represented by the task's page table), an object space (holding the kernel protected capabilities), and on X86 an IO-port address space. </li>
<li><b>Thread</b> A thread is bound to a task and executes code. Multiple threads can coexist in one task and are scheduled by the Fiasco scheduler. </li>
<li><b>Factory</b> A factory is used by applications to create new kernel objects. Access to a factory is required to create any new kernel object. Factories can control and restrict object creation. </li>
<li><b>IPC Gate</b> An IPC gate is used to create a secure communication channel between different tasks. It embeds a label (kernel protected payload) that securely identifies the gate through which a message is received. The gate label is not visible to and cannot be altered by the sender. </li>
<li><b>IRQ</b> IRQ objects provide access to hardware interrupts. Additionally, programs can create new virtual interrupt objects and trigger them. This allows to implement a signaling mechanism. The receiver cannot decide whether the interrupt is a physical or virtual one. </li>
<li><b>Vcon</b> Provides access to the in-kernel debugging console (input and output). There is only one such object in the kernel and it is only available, if the kernel is built with debugging enabled. This object is typically interposed through a user-level service or without debugging in the kernel can be completely based on user-level services. </li>
<li><b>Scheduler</b> Implements scheduling policy and assignment of threads to CPUs, including CPU statistics.</li>
</ul>
<h2><a class="anchor" id="main_l4re_sec"></a>
L4 Runtime Environment (L4Re)</h2>
<p>The <a class="el" href="namespaceL4.html" title="L4 low-level kernel interface.">L4</a> Runtime Environment (<a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a>) provides a basic set of services and abstractions, which are useful to implement and run user-level applications on top of the Fiasco.OC microkernel.</p>
<p><a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> consists of a set of libraries and servers. Libraries as well as server interfaces are completely object oriented. They implement prototype implementations for the classes defined by the <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> specification.</p>
<p>A minimal L4Re-based application needs 3 components to be booted beforehand: the Fiasco microkernel, the root pager (Sigma0), and the root task (Moe). The Sigma0 root pager initially owns all system resources, but is usually used only to resolve page faults for the Moe root task. Moe provides the essential services to normal user applications such as an initial program loader, a region-map service for virtual memory management, and a memory (data space) allocator.</p>
<h2><a class="anchor" id="l4re_concepts"></a>
Introduction to L4Re's concepts</h2>
<p>This section introduces basic concepts used by <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a>. Understanding of these concepts is a fundamental requirement to understand the inner workings of L4Re's software components and can dramatically help developers in efficiently developing L4Re-based software.</p>
<h2><a class="anchor" id="l4re_concepts_ds_rm"></a>
Memory management - Data Spaces and the Region Map</h2>
<h3><a class="anchor" id="l4re_concept_pagers"></a>
User-level paging</h3>
<p>Memory management in L4-based systems is done by user-level applications, the role is usually called <em>pager</em>. Tasks can give other tasks full or restricted access rights to parts of their own memory. The kernel offers means to grant the memory in a secure way, often referred to as <em>memory</em> mapping.</p>
<p>The described mechanism can be used to construct a memory hierarchy among tasks. The root of the hierarchy is <em>sigma0</em>, which initially gets all system resources and hands them out once on a first-come-first-served basis. Memory resources can be mapped between tasks at a page-size granularity. This size is predetermined by the CPU's memory management unit and is commonly set to 4 kB.</p>
<h3><a class="anchor" id="l4re_concept_data_spaces"></a>
Data spaces</h3>
<p>A data space is the <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> abstraction for objects which may be accessed in a memory mapped fashion (i.e., using normal memory read and write instructions). Examples include the sections of a binary which the loader attaches to the application's address space, files in the ROM or on disk provided by a file server, the registers of memory-mapped devices and anonymous memory such as the heap or the stack.</p>
<p>Anonymous memory data spaces in particular (but in general all data spaces except memory mapped IO) can either be constructed entirely from a portion of the RAM or the current working set may be multiplexed on some portion of the RAM. In the first case it is possible to eagerly insert all pages (more precisely page-frame capabilities) into the application's address space such that no further page faults occur when this data space is accessed. In general, however, only the pages for the some portion are provided and further pages are inserted by the pager as a result of page faults.</p>
<h3><a class="anchor" id="l4re_concept_regions"></a>
Virtual Memory Handling</h3>
<p>The virtual memory of each task is constructed from data spaces, backing virtual memory regions (VMRs). The management of the VMRs is provided by an object called <em>region</em> <em>map</em>. A dedicated region-map object is associated with each task, it allows to attach and detach data spaces to an address space as well as to reserve areas of virtual memory. Since the region-map object possesses all knowledge about virtual memory layout of a task, it also serves as an application's default pager.</p>
<h3><a class="anchor" id="l4re_concept_mem_alloc"></a>
Memory Allocation</h3>
<p>Operating systems commonly use anonymous memory for implementing dynamic memory allocation (e.g., using <em>malloc</em> or <em>new</em>). In an L4Re-based system, each task gets assigned a memory allocator providing anonymous memory using data spaces.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__api__l4re__dataspace.html">Data-Space API</a> and <a class="el" href="group__api__l4re__rm.html">Region map API</a>.</dd></dl>
<h2><a class="anchor" id="l4re_concepts_naming"></a>
Capabilities and Naming</h2>
<p>The <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> system is a capability based system which uses and offers capabilities to implement fine-grained access control.</p>
<p>Generally, owning a capability means to be allowed to communicate with the object the capability points to. All user-visible kernel objects, such as tasks, threads, and IRQs, can be accessed only through a capability. Please refer to the <a class="el" href="group__l4__kernel__object__api.html">Kernel Objects</a> documentation for details. Capabilities are stored in per-task capability tables (the object space) and are referenced by capability selectors or object flex pages. In a simplified view, a capability selector is a natural number indexing into the capability table of the current task.</p>
<p>As a matter of fact, a system designed solely based on capabilities, uses so-called 'local names', because each task can only access those objects made available to this task. Other objects are not visible to and accessible by the task.</p>
<div align="center">
<img src="l4-caps-basic.png" alt="l4-caps-basic.png"/>
<p><strong>Capabilities and Local Naming in L4</strong></p></div>
<p>So how does an application get access to service? In general all applications are started with an initial set of objects available. This set of objects is predetermined by the creator of a new application process and granted directly to into the new task before starting the first application thread. The application can then use these initial objects to request access to further objects or to transfer capabilities to own objects to other applications. A central <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> object for exchanging capabilities at runtime is the name-space object, implementing a store of named capabilities.</p>
<p>From a security perspective, the set of initial capabilities (access rights to objects) completely define the execution environment of an application. Mandatory security policies can be defined by well known properties of the initial objects and carefully handled access rights to them.</p>
<h2><a class="anchor" id="l4re_concepts_env_and_start"></a>
Initial Environment and Application Bootstrapping</h2>
<p>New applications that are started by a loader conforming to <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> get provided an <a class="el" href="group__api__l4re__env.html">initial environment</a>. This environment comprises a set of capabilities to initial <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> objects that are required to bootstrap and run this application. These capabilities include:</p>
<ul>
<li>A capability to an initial memory allocator for obtaining memory in the form of data spaces </li>
<li>A capability to a factory which can be used to create additional kernel objects </li>
<li>A capability to a Vcon object for debugging output and maybe input </li>
<li>A set of named capabilities to application specific objects</li>
</ul>
<p>During the bootstrapping of the application, the loader establishes data spaces for each individual region in the ELF binary. These include data spaces for the code and data sections, and a data space backed with RAM for the stack of the program's first thread.</p>
<p>One loader implementation is the <em>Moe</em> root task. Moe usually starts an <em>init</em> process that is responsible for coordinating the further boot process. The default <em>init</em> process is <em>Ned</em>, which implements a script-based configuration and startup of other processes. Ned uses Lua (<a href="http://www.lua.org">http://www.lua.org</a>) as its scripting language, see Ned Script example for more details.</p>
<h3><a class="anchor" id="l4re_ns_config"></a>
Configuring an application before startup</h3>
<p>The default <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> init process (Ned) provides a Lua script based configuration of initial capabilities and application startup. Ned itself also has a set of initial objects available that can be used to create the environment for an application. The most important object is a kernel object factory that allows creation of kernel objects such as IPC gates (communication channels), tasks, threads, etc. Ned uses Lua tables (associative arrays) to represent sets of capabilities that shall be granted to application processes.</p>
<div class="fragment"><pre class="fragment">  local caps = {
      name = some_capability
  }
</pre></div><p>The 'L4' Lua package in Ned also has support functions to create application tasks, region-map objects, etc. to start an ELF binary in a new task. The package also contains Lua bindings for basic <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> objects, for example, to generic factory objects, which are used to create kernel objects and also user-level objects provided by user-level servers.</p>
<div class="fragment"><pre class="fragment">  L4.default_loader:start({ caps = { some_service = service } }, <span class="stringliteral">&quot;rom/program --arg&quot;</span>);
</pre></div><h3><a class="anchor" id="l4re_config_connection"></a>
Connecting clients and servers</h3>
<p>In general, a connection between a client and a server is represented by a communication channel (IPC gate). That is available to the client and the server. You can see the simplest connection between a client and a server in the following example.</p>
<div class="fragment"><pre class="fragment">  local loader = L4.default_loader; -- which is Moe
  local svc = loader:new_channel();  -- create an IPC gate
  loader:start({ caps = { service = svc:full() }}, <span class="stringliteral">&quot;rom/my_server&quot;</span>);
  loader:start({ caps = { service = svc:m(<span class="stringliteral">&quot;rw&quot;</span>) }}, <span class="stringliteral">&quot;rom/my_client&quot;</span>);
</pre></div><p>As you can see in the snippet, the first action is to create a new channel (IPC gate) using <code>loader:new_channel()</code>. The capability to the gate is stored in the variable <code>svc</code>. Then the binary <code>my_server</code> is started in a new task, and full (<code></code>:full()) access to the IPC gate is granted to the server as initial object. The gate is accessible to the server application as "service" in the set of its initial capabilities. Virtually in parallel a second task, running the client application, is started and also given access to the IPC gate with less rights (<code></code>:m("rw"), note, this is essential). The server can now receive messages via the IPC gate and provide some service and the client can call operations on the IPC gate to communicate with the server.</p>
<p>Services that keep client specific state need to implement per-client server objects. Usually it is the responsibility of some authority (e.g., Ned) to request such an object from the service via a generic factory object that the service provides initially.</p>
<div class="fragment"><pre class="fragment">  local loader = L4.default_loader; -- which is Moe
  local svc = loader:new_channel():m(<span class="stringliteral">&quot;rws&quot;</span>);  -- create an IPC gate with rws rights
  loader:start({ caps = { service = svc:full() } }, <span class="stringliteral">&quot;rom/my-service&quot;</span>);
  loader:start({ caps = { foo_service = svc:create(object_to_create, <span class="stringliteral">&quot;param&quot;</span>) }}, <span class="stringliteral">&quot;rom/client&quot;</span>);
</pre></div><p>This example is quite similar to the first one, however, the difference is that Ned itself calls the create method on the factory object provided by the server and passes the returned capability of that request as "foo_service" to the client process.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The <code>svc:create</code>(..) call blocks on the server. This means the script execution blocks until the my-service application handles the create request.</dd></dl>
<h2><a class="anchor" id="l4re_concepts_stdio"></a>
Program Input and Output</h2>
<p>The initial environment provides a Vcon capability used as the standard input/output stream. Output is usually connected to the parent of the program and displayed as debugging output. The standard output is also used as a back end to the C-style printf functions and the C++ streams.</p>
<p>Vcon services are implemented in Moe and the loader as well as by the Fiasco kernel and connected either to the serial line or to the screen if available.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__l4__vcon__api.html">Virtual Console</a></dd></dl>
<h2><a class="anchor" id="l4re_concepts_memalloc"></a>
Initial Memory Allocator and Factory</h2>
<p>The purpose of the memory allocator and of the factory is to provide the application with the means to allocate memory (in the form of data spaces) and kernel objects respectively. An initial memory allocator and an initial factory are accessible via the allocation <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> environment.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__api__l4re__mem__alloc.html">Memory allocator API</a></dd></dl>
<p>The factory is a kernel object that provides the ability to create new kernel objects dynamically. A factory imposes a resource limit for kernel memory, and is thus a means to prevent denial of service attacks on kernel resources. A factory can also be used to create new factory objects.</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="group__l4__factory__api.html">Factory</a></dd></dl>
<h2><a class="anchor" id="l4re_concepts_apps_svr"></a>
Application and Server Building Blocks</h2>
<p>So far we have discussed the environment of applications in which a single thread runs and which may invoke services provided through their initial objects. In the following we describe some building blocks to extend the application in various dimensions and to eventually implement a server which implements user-level objects that may in turn be accessed by other applications and servers.</p>
<h3><a class="anchor" id="l4re_concepts_app_thread"></a>
Creating Additional Application Threads</h3>
<p>To create application threads, one must allocate a stack on which this thread may execute, create a thread kernel object and setup the information required at startup time (instruction pointer, stack pointer, etc.). In <a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> this functionality is encapsulated in the pthread library.</p>
<h3><a class="anchor" id="l4re_concepts_service"></a>
Providing a Service</h3>
<p>In capability systems, services are typically provided by transferring a capability to those applications that are authorised to access the object to which the capability refers to.</p>
<p>Let us discuss an example to illustrate how two parties can communicate with each other: Assume a simple file server, which implements an interface for accessing individual files: read(pos, buf, length) and write(pos, data, length).</p>
<p><a class="el" href="namespaceL4Re.html" title="L4 Runtime Environment.">L4Re</a> provides support for building servers based on the class <a class="el" href="classL4_1_1Server__object.html" title="Abstract server object to be used with the L4::Registry_dispatcher.">L4::Server_object</a>. <a class="el" href="classL4_1_1Server__object.html" title="Abstract server object to be used with the L4::Registry_dispatcher.">L4::Server_object</a> provides an abstract interface to be used with the <a class="el" href="classL4_1_1Server.html" title="Basic server loop for handling client requests.">L4::Server</a> class. Specific server objects such as, in our case, files inherit from <a class="el" href="classL4_1_1Server__object.html" title="Abstract server object to be used with the L4::Registry_dispatcher.">L4::Server_object</a>. Let us call this class File_object. When invoked upon receiving a message, the <a class="el" href="classL4_1_1Server.html" title="Basic server loop for handling client requests.">L4::Server</a> will automatically identify the corresponding server object based on the capability that has been provided to its clients and invoke this object's <em>dispatch</em> function with the incoming message as a parameter. Based on this message, the server must then decide which of the protocols it implements was invoked (if any). Usually, it will evaluate a protocol specific opcode that clients are required to transmit as one of the first words in the message. For example, assume our server assigns the following opcodes: Read = 0 and Write = 1. The <em>dispatch</em> function calls the corresponding server function (i.e., <em>File_object::read()</em> or <em>File_object::write()</em>), which will in turn parse additional parameters given to the function. In our case, this would be the position and the amount of data to be read or written. In case the write function was called the server will now update the contents of the file with the data supplied. In case of a read it will store the requested part of the file in the message buffer. A reply to the client finishes the client request. </p>
</div>
    <div style="background-color: #fff; border-width: 1px 0 0 0; border-color: #000; border-style: solid; text-align: center; margin-top: 10px">
    L4Re - L4 Runtime Environment
    </div>
   </div>
  </body>
</html>
